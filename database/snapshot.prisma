datasource db {
	provider = "sqlite"
	url      = env("SNAPSHOT_FILE")
}

generator client {
	provider = "prisma-client-js"
	output = "clients/snapshot"
	previewFeatures = ["interactiveTransactions"]
}

model SnapshotHistory {
	id Int @id @default(autoincrement())
	ledgerIndex Int @unique
	ledgerCloseTime DateTime
	snapshotTime DateTime @default(now())
	entriesCount Int @default(value: 0)
	diffed Boolean
	captureRestoration String?
}

model Account {
	id Int @id @default(autoincrement())
	address Bytes @unique
	balance BigInt
	domain Bytes?
	emailHash Bytes?

	currencyOffers CurrencyOffer[]
	owningNFTokens NFToken[] @relation(name: "nto") 
	issuedNFTokens NFToken[] @relation(name: "nfi")
	nfTokenOffers NFTokenOffer[] @relation(name: "nfoo")
	nfTokenOfferAmounts NFTokenOffer[] @relation(name: "nfoai")
	nfTokenOffersForAccount NFTokenOffer[] @relation(name: "nfod")
	lowRippleStates RippleState[] @relation(name: "low")
	highRippleStates RippleState[] @relation(name: "high")
	paysCurrencyOffers CurrencyOffer[] @relation(name: "copi")
	getsCurrencyOffers CurrencyOffer[] @relation(name: "cogi")
}

model RippleState {
	id Int @id @default(autoincrement())
	currencyId Int
	lowAccountId Int
	highAccountId Int
	balance BigInt

	currency Currency? @relation(fields: [currencyId], references: [id])
	lowAccount Account @relation(name: "low", fields: [lowAccountId], references: [id])
	highAccount Account @relation(name: "high", fields: [highAccountId], references: [id])

	@@unique([currencyId, lowAccountId, highAccountId])
}

model Currency {
	id Int @id @default(autoincrement())
	code Bytes @unique

	rippleStates RippleState[]
	offersPaying CurrencyOffer[] @relation(name: "copc")
	offersGetting CurrencyOffer[] @relation(name: "cogc")
	nftOffers NFTokenOffer[]
}

model CurrencyOffer {
	id Int @id @default(autoincrement())
	accountId Int
	sequence Int
	takerPaysCurrencyId Int?
	takerPaysIssuerId Int?
	takerPaysValue BigInt
	takerGetsCurrencyId Int?
	takerGetsIssuerId Int?
	takerGetsValue BigInt
	expiration DateTime?

	account Account @relation(fields: [accountId], references: [id])
	takerPaysCurrency Currency? @relation(name: "copc", fields: [takerPaysCurrencyId], references: [id])
	takerPaysIssuer Account? @relation(name: "copi", fields: [takerPaysIssuerId], references: [id])
	takerGetsCurrency Currency? @relation(name: "cogc", fields: [takerGetsCurrencyId], references: [id])
	takerGetsIssuer Account? @relation(name: "cogi", fields: [takerGetsIssuerId], references: [id])
}

model NFToken {
	id Int @id @default(autoincrement())
	ownerId Int
	issuerId Int
	tokenId Bytes
	uri String?

	owner Account @relation(name: "nto", fields: [ownerId], references: [id])
	issuer Account @relation(name: "nfi", fields: [issuerId], references: [id])
}

model NFTokenOffer {
	id Int @id @default(autoincrement())
	ownerId Int
	tokenId Bytes
	amountCurrencyId Int?
	amountCurrencyIssuer Int?
	amountValue BigInt
	buy Boolean
	destinationId Int?
	expiration DateTime?

	owner Account @relation(name: "nfoo", fields: [ownerId], references: [id])
	amountCurrency Currency? @relation(fields: [amountCurrencyId], references: [id])
	amountIssuer Account? @relation(name: "nfoai", fields: [amountCurrencyIssuer], references: [id])
	destination Account? @relation(name: "nfod", fields: [destinationId], references: [id])
}